using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace TypeBase
{
    public partial class Sample
    {
        #region Ссылочные и значимые типы
        // - Значимыми типами являются структуры и перечисления,
        // унаследовавшие класс System.ValueType. Например: 
        // int (структура System.Int32)
        // - Ссылочными типами являются все классы (или всё, что не
        // от System.ValueType).
        // - Работая с типами Framework легко определить его природу,
        // заглянув в документацию. Однако, может возникнуть необходимость
        // динамического определения того, каким является тип. Это
        // делается так:
        // (некий тип).GetType().IsValueType
        // если = true, тип значимый. Иначе - ссылочный.
        //-------------------------------------------------------------
        // Значимые типы размещаются в стеке, а у ссылочных типов
        // в стеке размещены адреса их значений, тогда как сами
        // значения расположены в куче (heap).
        //-------------------------------------------------------------
        // Создадим объект класса: People ppl = new People();
        // 
        // Эту строку можно переписать так:
        // People ppl;
        // ppl = new People();
        //
        // Проанализируем:
        // 1 строка. Объявляется переменная ppl, которая является
        //   ссылкой на объект типа People. В этот момент переменная
        //   содержит значение null (т.е. пока не ссылается на объект).
        // 2 строка. Создается реальный объект класса People, а ссылка на
        //   него передается переменной ppl.

        //  Как известно, в С++ указатели - это переменные, которые содержат
        // адрес некоторой другой переменной. Понятие указателя в С# остается,
        // но понятие ссылки несколько видоизменяется.
        // В С# ссылка и указатель практически одно и то же, но указатель может
        // содержать адрес какого угодно объекта, а ссылка только объекта своего
        // конкретного типа.
        #endregion
        
        public static void Demo()
        {
            // Прверим тип переменных
            Console.WriteLine("Тип значения? - " + "пример".GetType().IsValueType); // false
            int[] ar = { 1, 2, 3 };
            Console.WriteLine("Тип значения? - " + ar.GetType().IsValueType); // false
            Console.WriteLine("Тип значения? - " + (10.55).GetType().IsValueType); // true
            //------------------------------------------------------------
            int A = 10; int B = 20;
            Swap(A, B);  // ничего не даст
            Console.WriteLine("A = {0}, B = {1}", A, B); // A = 10, B = 20
            //------------------------------------------------------------
            //  ref  -  передача параметра по ссылке
            //------------------------------------------------------------
            Swap(ref A, ref B);
            Console.WriteLine("A = {0}, B = {1}", A, B); // A = 20, B = 10
            //------------------------------------------------------------
            A a_ob = new A(10);
            B b_ob = new B(20);
            Swap(a_ob, b_ob);
            Console.WriteLine("A.a = {0}, B.b = {1}", a_ob.a, b_ob.b); // 20 10
        }

        // функция, которая должна менять значения переменных
        // местами... но не делает этого.
        public static void Swap(int a, int b)
        {
            // функция оперирует копиями объектов, поэтому
            // значения аргументов не изменяются
            int temp = a;
            a = b;
            b = temp;
        }
        // эта функция работает не с копиями объектов, а
        // с ссылками на них.
        public static void Swap(ref int a, ref int b)
        {
            int temp = a;
            a = b;
            b = temp;
        }

        public static void Swap(A _A, B _B)
        {
            int temp = _A.a;
            _A.a = _B.b;
            _B.b = temp;
        }

        public class A
        {
            public A(int _a) { a = _a; }
            public int a;
        }
        public class B
        {
            public B(int _b) { b = _b; }
            public int b;
        }
    }
}
